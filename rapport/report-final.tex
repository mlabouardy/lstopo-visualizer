\documentclass [a4paper,11pt]{article}

\usepackage [francais]{babel}
\usepackage[utf8]{inputenc}%       encodage du fichier source
\usepackage[T1]{fontenc}%          gestion des accents (pour les pdf)
\usepackage[a4paper]{geometry}%    taille correcte du papier
\usepackage{hyperref}%			   gestion des hyperliens
\usepackage{graphicx}%			   gestion des images
\usepackage{fancyhdr}%
\usepackage{lastpage}%			   pour avoir le numero de page
\usepackage{fancyvrb}%			   meilleur verbatim
\usepackage{chngcntr}%			   pour numéroté les figures au lieux du numéro de section
\usepackage[toc,page]{appendix}%   pour les annexes

% Chemin par defaut des images
\graphicspath{{img/}}

\pagestyle{fancyplain}
\fancyhf{}
\cfoot{\thepage\ sur \pageref{LastPage}}


\begin{document}

\begin{titlepage}
\begin{center}
{\bf Université Sciences et Technologies - Bordeaux1} \vspace{0.5cm}\\

{\bf {\large Master 2 Informatique : Genie logiciel parcours conduite de projet}}\\
%{\emph{Rapport du Projet d'Etude et de Développement }}\\\vspace{1cm}

\begin{figure}[!ht]
  \centering
  \includegraphics[scale=0.2]{img/uniBx-logo}

  \label{fig:logUniBx}
\end{figure}


{\large{\bf{Rapport:}}}\\\vspace{1cm}
{\huge{\bf Visualisation interactive de topologie de plates-formes parallèles avec lstopo et HTML}}\\\vspace{0.5cm}





\end{center}

\hspace{1cm}\textbf{Réalisé par:} GreenScrum \\
%\bigskip

\hspace{1cm}\textbf{Encadré par:} Philippe Narbel , David Auber.\\


\hspace{1cm}\textbf{Client:} Brice Goglin\\



\end{titlepage}





\tableofcontents

\newpage

\section{Introduction}

\subsection{Présentation du projet}
Le but du projet est de proposer un logiciel de visualisation au format HTML d'une topologie de machines. Cette topologie est constituée d'informations matérielles de chaque machine. Ces données servent à àméliorer les calculs parallèles en optimisant l'utilisation du matériel. Les données à utiliser sont extraites du module lstopo de la bibliothèque logicielle hwloc

\subsection{Réalisation du projet}
Le projet devait être fait en 2 parties avec une partie en C et une partie Web. Le but de la 1ère partie devait être de créer une exportation des données à visualiser. Mais, après discussion avec le client, nous avons compris que ce n'est pas nécessaire. En effet, une exportation au format XML existe déjà, et elle est suffisante pour fournir les données nécessaires à la création de l'application de visualisation.

\newpage
\section{Architecture}

\subsection{MVC}

\subsection{Technologies}

\subsection{Fonctionnalités}

Pendant l'ensemble du projet nous avons réalisé les deux principales fonctionnalités qui sont : \newline

\begin{itemize}
\item La visualisation du fichier xml généré par hwloc pour tous les exemples possibles contenant des groupes, des packages etc ... : 

\begin{figure}[!h]
\centering
\includegraphics[scale=0.5]{img/alaric.png}
\caption[Résultats]{Exemple de représentation pour le xml Alaric}
\end{figure}

\item La seconde partie représente les option permettant de personnalisé l'affichage. Il contient : \newline
- la possibilité de caché ou rendre visible certains éléments de la représentation comme les différents caches, la partie PCI ou des plus grosses entités comme des packages, groupes ou autres. \newline
- une personnalisation des couleurs pour l'ensemble des objets. \newline
- changer la taille de police de caractère. \newline
- exporter au format PDF ou PNG l'ensemble des représentations.
- la possibilité d'enregistré sur notre machine la configuration des couleurs pour pouvoir la réutilisé plus tard et bien sur la possibilité de charger une configuration existante.

\begin{figure}[!h]
\centering
\includegraphics[scale=0.3]{img/filtre.png}
\caption[Résultats]{ Interface graphique du menu d'option }
\end{figure}

\begin{figure}[!h]
\centering
\includegraphics[scale=0.3]{img/alaric_modif.png}
\caption[Résultats]{Exemple de représentation pour le xml Alaric avec options}
\end{figure}

\end{itemize}

\newpage

\section{Intégration Continue}

Intégration continue est une étape importante à mettre en place dans le processus de développement logiciel. Nous parlerons donc ici de cette pratique et de l'outil utilisé au cours de ce projet.

\begin{center}
\includegraphics[scale=0.5]{img/ci.png}
\end{center}

Au moment d’un push d’un ou plusieurs commit au niveau de Bitbucket (sur la banche \textbf{release}) on déclenche via un hook la tâche de build qui permet la construction de l'image Docker à partir de Dockerfile, le push de cette image dans un dépot privé, le déploiement de cette image dans un container exposer sur le port 80 et enfin de passage des TUs au niveau de Jenkins. Dès qu’une modification du code est donc poussée sur le repository, il y a vérification que l’ensemble fonctionne toujours.

\begin{center}
\includegraphics[scale=0.7]{img/Dockerfile.png}
\end{center}

\subsection{Bitbucket}

Un système de versionnement, il a été choisi pour héberger les sources des projets internes et clients. Pour notre projet on a utilisé 3 branches:\newline

\begin{itemize}
 \item \textbf{master} utilisé pour la phase de développement
 \item \textbf{release} utilisé pour la phase de production
 \item \textbf{docs} utilisé pour les documents (rapport, maquettes, cadrage ...)
\end{itemize}

\subsection{Jenkins}

Serveur d'intégration continue, il est capable d’aller se connecter à un outil de gestion de sources (Dans ce cas Git) et de voir si des modifications ont été effectuées. S’il en détecte, il peut lancer un \textbf{build} qui va pouvoir lancer un certain nombre d’actions(déploiement automatisé, tests unitaires ...)

\subsection{Docker}

Docker est un système de container linux ultra léger basé sur les cgroups, lxc et aufs.\newline

L'idée est la suivante pour un build:\newline

\begin{itemize}
 \item Jenkins crée une image docker à partir de Dockerfile
 \item Jenkins push l'image dans un dépot privé
 \item Jenkins crée un container docker à partir de cette image\newline
\end{itemize}
\newline
Les containers sont running de manière continue, permettant ainsi aux responsables du projet et au client de tester la dernière version du produit poussé manuellement à partir de Jenkins.

\subsection{Private Registry}

Depot pour stocker l'ensemble des versions de l'application tout au long de la phase de développement

\begin{center}
\includegraphics[scale=0.4]{img/registry.png}
\end{center}

L'avatange d'utilisation d'un docker private registry c'est avoir un systéme de versionning pour l'application. et rendre disponible facilement le dernier exécutable.
\subsection{Selenium Webdriver}
WebDriver est un framework de tests fonctionnels issu du projet Selenium, célèbre outil d'automatisation de tests pour navigateurs.\newline

Un exemple des test faites avec l'API Selenium c'est la mesure du temps d'execution pour un ensemble des exemples d'Architecture.

\begin{center}
\includegraphics[scale=0.4]{img/benchmark.png}
\end{center}

\subsection{JSLint/CSSLint}

La qualité du code est vitale pour qu'un projet soit pérenne sur le moyen et long terme. De nombreux outils existent pour automatiser les contrôles et générer des rapports statistiques:\newline

\textbf{JSLint} est un analyseur de code Javascript. Son but est de parser le code Javascript pour vérifier que vous respecter les règles de coding Javascript.\newline

\begin{center}
\includegraphics[scale=0.4]{img/checkstyle.png}
\end{center}

\textbf{CSSLint} détecte les problèmes d'une feuille de style CSS.

\begin{center}
\includegraphics[scale=0.4]{img/jslint.png}
\end{center}

\subsection{AngularJS Batarang}

Afin de développer tester, déboguer et surveiller notre application AngularJS, on a installé un plugin sur le navigateur:\newline

Une extension de Google Chrome. Il permet d'observer le code en action, de faire des benchmarks sur les fonctions, modules, etc...

\newpage
\section{Gestion de projet}

\subsection{Scrum}

Durant l'ensemble du projet nous avons suivi la méthode Scrum qui est une méthode agile. Pour cela nous avons utilisé le logiciel Icescrum. Il nous permet de définir un backlog, différents sprints avec les User Stories à réaliser et les différentes taches de ces US. Dans chaque sprint on peut définir le kanban pour les différentes tâches et connaitre l'évolution leurs taches. Nous avons choisi de réaliser des sprints de deux semaines comme c'était prévu à la base. 
Pour les taches nous avons choisi différentes couleurs afin de différencier les différents groupes de taches. Il y a :
\begin{itemize}
\item Taches jaune : Elles représentent le code produit pour le projet.
\item Taches bleu : Elles représentent les tests de validations pour notre code.
\item Taches grise : Elles représentent les tests d'intégrations.
\item Taches rouges : Elles représentent les recherches concernant certaines bibliothèques non mis en place et le rapport.
\end{itemize}

Par la suite on peut regarder l'évolution du projet avec le burn down chart qui est disponible pour chaque projet.

\subsection{Outils complémentaires}

\newpage

\newpage

\section{Critiques}

\subsection{Technologies}

\subsection{IceScrum}

\subsection{Performances}

\subsection{Améliorations possibles}

\newpage

\nocite{*}
\bibliographystyle{plain}
\bibliography{report}




\end{document}
